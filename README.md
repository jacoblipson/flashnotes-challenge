#README

Author: Jacob Lipson

Date: 4/26/2015

Description: An implementation of a First-in, First-out priority queue

Files: Task.java, TaskQueue.java, TaskResult.java, Test.java

Status: Task, TaskQueue, and TaskResult are fully implemented. Task's execute method has temporarily been modified to return a TaskResult. TaskResults has not yet been implemented. Task has been thoroughly tested. TaskQueue has been tested. TaskResult has not been tested.

###To Run:
1) Clone the repository from Github

2) Open a terminal window or command line and navigate to the folder 'flashnotes-challenge'. 

3) Modify the file Test.java to run whatever tests you'd like, or import your own test file

4) Run the following compile script:
	javac *.java

5) Run the following test script:
	java Test


###Class Descriptions

####Task
Members:

GUID - Randomly created, unique identifier generated by Java's UUID class

description - Text provided at creation of Task instance

command - Command line code provided at creation of Task instance

Methods:

execute() - Runs the Task's stored command in the application's environment, creates a TaskResult and returns it

####TaskQueue
Members:

queue - Linked List used to represent the FIFO queue

Methods:

push() - Adds a task to the bottom of the queue

pop() - Removes and returns the task on the top of the queue

peek_next() - Returns a copy of the task on the top of the queue

peek_all() - Returns a Java List of copies of the tasks on the queue in proper order

count() - Returns the size of the queue

###TaskResult
Members:

task_guid - the original task's GUID

suceeded - boolean for if task ran without exception

return_code - the return code the task's execute returns

output - the stdout dump for the task in String format

exception - if an exception occurred, String containing message, else empty String

execution_duration - length of time the task took to run in nanoseconds

###Design Choices:
I chose to solve this problem in Java as it is both my most comfortable programming language, and one that easily lent itself to a solution. Java's numberous libraries made solving the various challenges in this problem simple. I chose a Linked List as the data structure to represent the TaskQueue because it offered methods for every feature of the TaskQueue, except peek_all. For peek_all, it was equally easy to copy the Linked List into an ArrayList, then into a List. Java also offered the UUID class, for easy GUID creation.